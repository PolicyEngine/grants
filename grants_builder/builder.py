"""Build all grant viewers from grant directories."""

import json
import yaml
from pathlib import Path

from .utils import strip_markdown_formatting


def _old_strip_markdown_formatting(text):
    """Remove markdown formatting to get plain text."""
    # Remove headers
    text = re.sub(r'^#+\s+', '', text, flags=re.MULTILINE)
    # Remove bold/italic
    text = re.sub(r'\*\*([^*]+)\*\*', r'\1', text)
    text = re.sub(r'\*([^*]+)\*', r'\1', text)
    text = re.sub(r'__([^_]+)__', r'\1', text)
    text = re.sub(r'_([^_]+)_', r'\1', text)
    # Remove links but keep text
    text = re.sub(r'\[([^\]]+)\]\([^\)]+\)', r'\1', text)
    # Remove list markers
    text = re.sub(r'^\s*[-*+]\s+', '', text, flags=re.MULTILINE)
    text = re.sub(r'^\s*\d+\.\s+', '', text, flags=re.MULTILINE)
    # Remove code blocks
    text = re.sub(r'```[^`]*```', '', text, flags=re.DOTALL)
    text = re.sub(r'`([^`]+)`', r'\1', text)
    # Remove blockquotes
    text = re.sub(r'^>\s+', '', text, flags=re.MULTILINE)
    # Clean up extra whitespace
    text = re.sub(r'\n\n+', '\n\n', text)
    return text.strip()


def process_grant(grant_id, grant_config):
    """Process a single grant application."""
    grant_path = Path(grant_config['path'])

    if not grant_path.exists():
        print(f"Warning: {grant_path} not found")
        return None

    # Load grant metadata
    grant_yaml_path = grant_path / 'grant.yaml'
    if grant_yaml_path.exists():
        with open(grant_yaml_path) as f:
            grant_metadata = yaml.safe_load(f)
    else:
        grant_metadata = {}

    # Load questions
    questions_path = grant_path / 'questions.yaml'
    if not questions_path.exists():
        # Try old location (pritzker_questions.yaml)
        questions_path = grant_path / f'{grant_id}_questions.yaml'

    with open(questions_path) as f:
        questions_data = yaml.safe_load(f)

    # Process responses
    responses = {}
    sections = questions_data.get('sections', {})

    # Handle both dict format (Pritzker) and list format (PBIF)
    if isinstance(sections, list):
        # Convert list to dict for uniform processing
        sections = {item.get('id', f"section_{i}"): item for i, item in enumerate(sections) if 'file' in item}
    elif not isinstance(sections, dict):
        sections = {}

    for section_key, section_data in sections.items():
        response_file = grant_path / section_data['file'].replace('responses/', 'responses/')

        if not response_file.exists():
            print(f"Warning: {response_file} not found")
            continue

        # Read response
        response_markdown = response_file.read_text()

        # Validation: Check if response starts with question text
        question_text = section_data.get('question', '')
        if question_text and response_markdown.strip().startswith(f"# {question_text}"):
            print(f"   âš ï¸  WARNING: {response_file.name} starts with question text - this will be included in the response!")
            print(f"      Remove the H1 header: '# {question_text[:50]}...'")

        plain_text = strip_markdown_formatting(response_markdown)

        char_limit = section_data.get('char_limit', 10000)
        char_count = len(plain_text)
        char_percentage = (char_count / char_limit) * 100

        needs_completion = '[NEEDS TO BE COMPLETED]' in response_markdown or '[TO BE COMPLETED]' in response_markdown

        responses[section_key] = {
            'title': section_data['title'],
            'question': section_data.get('question', ''),
            'file': str(response_file.relative_to(grant_path)),
            'plainText': plain_text,
            'charCount': char_count,
            'charLimit': char_limit,
            'charPercentage': round(char_percentage, 1),
            'overLimit': char_count > char_limit,
            'needsCompletion': needs_completion,
            'status': 'needs_input' if (char_count > char_limit or needs_completion) else 'complete'
        }

    return {
        'id': grant_id,
        'config': grant_config,
        'metadata': grant_metadata,
        'responses': responses
    }


def build_all_grants(registry_path="grant_registry.yaml", output_dir="docs"):
    """Build all grant viewers."""
    # Load registry
    with open('grant_registry.yaml') as f:
        registry = yaml.safe_load(f)

    grants_data = {}

    print("Processing grants...")
    for grant_id, grant_config in registry['grants'].items():
        print(f"\nðŸ“‹ Processing {grant_id}...")
        grant_data = process_grant(grant_id, grant_config)
        if grant_data:
            grants_data[grant_id] = grant_data
            response_count = len(grant_data['responses'])
            print(f"   âœ… {response_count} responses processed")

    # Write to JavaScript
    docs_path = Path('docs')
    docs_path.mkdir(exist_ok=True)

    js_content = f"""// Auto-generated by build_all.py
// DO NOT EDIT MANUALLY

const grantsData = {json.dumps(grants_data, indent=2)};
"""

    (docs_path / 'grants_data.js').write_text(js_content)
    print(f"\nâœ… Generated docs/grants_data.js")
    print(f"âœ… Processed {len(grants_data)} grants")

    # Print summary
    print("\n" + "="*60)
    print("GRANT SUMMARY")
    print("="*60)
    for grant_id, data in grants_data.items():
        print(f"\n{data['config']['name']}")
        print(f"  Foundation: {data['config']['foundation']}")
        print(f"  Amount: ${data['config']['amount_requested']:,}")
        print(f"  Status: {data['config']['status']}")
        print(f"  Responses: {len(data['responses'])}")


if __name__ == '__main__':
    build_all_grants()
